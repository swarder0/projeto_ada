<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/endpoint/GetClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/endpoint/GetClient.kt" />
              <option name="originalContent" value="package com.example.demo.endpoint&#10;&#10;import com.example.demo.model.Client&#10;import com.example.demo.model.Account&#10;import com.example.demo.model.Payment&#10;import org.springframework.web.bind.annotation.GetMapping&#10;import org.springframework.web.bind.annotation.PathVariable&#10;import org.springframework.web.bind.annotation.RequestMapping&#10;import org.springframework.web.bind.annotation.RestController&#10;&#10;&#10;@GetMapping(&quot;/clients/{id}&quot;)&#10;@RestController&#10;@RequestMapping(&quot;/api&quot;)&#10;class GetClient {" />
              <option name="updatedContent" value="package com.example.demo.endpoint&#10;&#10;import com.example.demo.model.Client&#10;import com.example.demo.repository.ClientRepository&#10;import org.springframework.http.ResponseEntity&#10;import org.springframework.web.bind.annotation.GetMapping&#10;import org.springframework.web.bind.annotation.PathVariable&#10;import org.springframework.web.bind.annotation.RequestMapping&#10;import org.springframework.web.bind.annotation.RestController&#10;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api&quot;)&#10;class GetClient(private val clientRepository: ClientRepository) {&#10;    @GetMapping(&quot;/clients/{id}&quot;)&#10;    fun getClientById(@PathVariable id: Long): ResponseEntity&lt;Client&gt; {&#10;        val client = clientRepository.findById(id)&#10;        return if (client.isPresent) {&#10;            ResponseEntity.ok(client.get())&#10;        } else {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/kotlin/com/example/demo/service/TransactionServiceTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/kotlin/com/example/demo/service/TransactionServiceTest.kt" />
              <option name="originalContent" value="package com.example.demo.service&#10;&#10;import com.example.demo.model.*&#10;import com.example.demo.repository.AccountRepository&#10;import com.example.demo.repository.TransactionRepository&#10;import io.mockk.every&#10;import io.mockk.mockk&#10;import io.mockk.slot&#10;import io.mockk.verify&#10;import org.junit.jupiter.api.Assertions.*&#10;import org.junit.jupiter.api.BeforeEach&#10;import org.junit.jupiter.api.Test&#10;import java.time.LocalDateTime&#10;import java.util.*&#10;&#10;class TransactionServiceTest {&#10;    private lateinit var transactionRepository: TransactionRepository&#10;    private lateinit var accountRepository: AccountRepository&#10;    private lateinit var transactionService: TransactionService&#10;&#10;    @BeforeEach&#10;    fun setUp() {&#10;        transactionRepository = mockk(relaxed = true)&#10;        accountRepository = mockk(relaxed = true)&#10;        transactionService = TransactionService(transactionRepository, accountRepository)&#10;    }&#10;&#10;    @Test&#10;    fun `deve realizar deposito com sucesso`() {&#10;        // given&#10;        val account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(account)&#10;        val slotAccount = slot&lt;Account&gt;()&#10;        every { accountRepository.save(capture(slotAccount)) } answers { slotAccount.captured }&#10;        val slotTransaction = slot&lt;Transaction&gt;()&#10;        every { transactionRepository.save(capture(slotTransaction)) } answers { slotTransaction.captured }&#10;&#10;        // when&#10;        val transaction = transactionService.deposit(1, 50.0, &quot;Depósito Teste&quot;)&#10;&#10;        // then&#10;        assertEquals(150.0, slotAccount.captured.balance)&#10;        assertEquals(TransactionType.DEPOSIT, transaction.type)&#10;        assertEquals(50.0, transaction.amount)&#10;        assertEquals(&quot;Depósito Teste&quot;, transaction.description)&#10;        assertNotNull(transaction.createdAt)&#10;        assertEquals(TransactionStatus.COMPLETED, transaction.status)&#10;    }&#10;&#10;    @Test&#10;    fun `nao deve permitir deposito com valor negativo`() {&#10;        // given, when, then&#10;        val exception = assertThrows(IllegalArgumentException::class.java) {&#10;            transactionService.deposit(1, -10.0, &quot;Depósito Negativo&quot;)&#10;        }&#10;        assertEquals(&quot;O valor do depósito deve ser maior que zero.&quot;, exception.message)&#10;    }&#10;&#10;    @Test&#10;    fun `deve realizar saque com sucesso`() {&#10;        // given&#10;        val account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(account)&#10;        val slotAccount = slot&lt;Account&gt;()&#10;        every { accountRepository.save(capture(slotAccount)) } answers { slotAccount.captured }&#10;        val slotTransaction = slot&lt;Transaction&gt;()&#10;        every { transactionRepository.save(capture(slotTransaction)) } answers { slotTransaction.captured }&#10;&#10;        // when&#10;        val transaction = transactionService.withdraw(1, 40.0, &quot;Saque Teste&quot;)&#10;&#10;        // then&#10;        assertEquals(60.0, slotAccount.captured.balance)&#10;        assertEquals(TransactionType.WITHDRAWAL, transaction.type)&#10;        assertEquals(40.0, transaction.amount)&#10;        assertEquals(&quot;Saque Teste&quot;, transaction.description)&#10;        assertNotNull(transaction.createdAt)&#10;        assertEquals(TransactionStatus.COMPLETED, transaction.status)&#10;    }&#10;&#10;    @Test&#10;    fun `nao deve permitir saque com saldo insuficiente`() {&#10;        // given&#10;        val account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 20.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(account)&#10;        // when, then&#10;        val exception = assertThrows(IllegalArgumentException::class.java) {&#10;            transactionService.withdraw(1, 50.0, &quot;Saque Teste&quot;)&#10;        }&#10;        assertEquals(&quot;Saldo insuficiente para realizar o saque.&quot;, exception.message)&#10;    }&#10;&#10;    @Test&#10;    fun `deve realizar transferencia com sucesso`() {&#10;        // given&#10;        val fromAccount = Account(id = 1, accountNumber = &quot;123&quot;, balance = 200.0)&#10;        val toAccount = Account(id = 2, accountNumber = &quot;456&quot;, balance = 50.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(fromAccount)&#10;        every { accountRepository.findByAccountNumber(&quot;456&quot;) } returns toAccount&#10;        val slotFrom = slot&lt;Account&gt;()&#10;        val slotTo = slot&lt;Account&gt;()&#10;        every { accountRepository.save(capture(slotFrom)) } answers { slotFrom.captured }&#10;        every { accountRepository.save(capture(slotTo)) } answers { slotTo.captured }&#10;        val slotOut = slot&lt;Transaction&gt;()&#10;        val slotIn = slot&lt;Transaction&gt;()&#10;        every { transactionRepository.save(capture(slotOut)) } answers { slotOut.captured }&#10;        every { transactionRepository.save(capture(slotIn)) } answers { slotIn.captured }&#10;&#10;        // when&#10;        val (outTransaction, inTransaction) = transactionService.transfer(1, &quot;456&quot;, 100.0, &quot;Transferência Teste&quot;)&#10;&#10;        // then&#10;        assertEquals(100.0, slotFrom.captured.balance)&#10;        assertEquals(150.0, slotTo.captured.balance)&#10;        assertEquals(TransactionType.TRANSFER_OUT, outTransaction.type)&#10;        assertEquals(TransactionType.TRANSFER_IN, inTransaction.type)&#10;        assertEquals(100.0, outTransaction.amount)&#10;        assertEquals(100.0, inTransaction.amount)&#10;        assertEquals(&quot;Transferência Teste&quot;, outTransaction.description)&#10;        assertEquals(&quot;Transferência Teste&quot;, inTransaction.description)&#10;    }&#10;&#10;    @Test&#10;    fun `nao deve permitir transferencia para mesma conta`() {&#10;        // given&#10;        val fromAccount = Account(id = 1, accountNumber = &quot;123&quot;, balance = 200.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(fromAccount)&#10;        every { accountRepository.findByAccountNumber(&quot;123&quot;) } returns fromAccount&#10;        // when, then&#10;        val exception = assertThrows(IllegalArgumentException::class.java) {&#10;            transactionService.transfer(1, &quot;123&quot;, 50.0, &quot;Transferência Inválida&quot;)&#10;        }&#10;        assertEquals(&quot;Não é possível transferir para a mesma conta.&quot;, exception.message)&#10;    }&#10;&#10;    @Test&#10;    fun `deve buscar transacoes por conta`() {&#10;        // given&#10;        val accountId = 1L&#10;        val transactions = listOf(&#10;            Transaction(id = 1, account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0), type = TransactionType.DEPOSIT, amount = 50.0, description = &quot;Depósito&quot;, createdAt = LocalDateTime.now()),&#10;            Transaction(id = 2, account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 150.0), type = TransactionType.WITHDRAWAL, amount = 20.0, description = &quot;Saque&quot;, createdAt = LocalDateTime.now())&#10;        )&#10;        every { transactionRepository.findByAccountIdOrderByCreatedAtDesc(accountId) } returns transactions&#10;        // when&#10;        val result = transactionService.getTransactionsByAccount(accountId)&#10;        // then&#10;        assertEquals(2, result.size)&#10;        assertEquals(TransactionType.DEPOSIT, result[0].type)&#10;        assertEquals(TransactionType.WITHDRAWAL, result[1].type)&#10;    }&#10;&#10;    @Test&#10;    fun `deve buscar ultimas 10 transacoes por conta`() {&#10;        // given&#10;        val accountId = 1L&#10;        val transactions = List(10) {&#10;            Transaction(id = it.toLong(), account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0), type = TransactionType.DEPOSIT, amount = 10.0, description = &quot;Depósito $it&quot;, createdAt = LocalDateTime.now())&#10;        }&#10;        every { transactionRepository.findTop10ByAccountIdOrderByCreatedAtDesc(accountId) } returns transactions&#10;        // when&#10;        val result = transactionService.getRecentTransactionsByAccount(accountId)&#10;        // then&#10;        assertEquals(10, result.size)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.demo.service&#10;&#10;import com.example.demo.model.*&#10;import com.example.demo.repository.AccountRepository&#10;import com.example.demo.repository.TransactionRepository&#10;import io.mockk.every&#10;import io.mockk.mockk&#10;import io.mockk.slot&#10;import io.mockk.verify&#10;import org.junit.jupiter.api.Assertions.*&#10;import org.junit.jupiter.api.BeforeEach&#10;import org.junit.jupiter.api.Test&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import java.util.*&#10;&#10;class TransactionServiceTest {&#10;    private lateinit var transactionRepository: TransactionRepository&#10;    private lateinit var accountRepository: AccountRepository&#10;    private lateinit var transactionService: TransactionService&#10;&#10;    @BeforeEach&#10;    fun setUp() {&#10;        transactionRepository = mockk(relaxed = true)&#10;        accountRepository = mockk(relaxed = true)&#10;        transactionService = TransactionService(transactionRepository, accountRepository)&#10;    }&#10;&#10;    @Test&#10;    fun `deve realizar deposito com sucesso`() {&#10;        // given&#10;        val account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(account)&#10;        val slotAccount = slot&lt;Account&gt;()&#10;        every { accountRepository.save(capture(slotAccount)) } answers { slotAccount.captured }&#10;        val slotTransaction = slot&lt;Transaction&gt;()&#10;        every { transactionRepository.save(capture(slotTransaction)) } answers { slotTransaction.captured }&#10;&#10;        // when&#10;        val transaction = transactionService.deposit(1, 50.0, &quot;Depósito Teste&quot;)&#10;&#10;        // then&#10;        assertEquals(150.0, slotAccount.captured.balance)&#10;        assertEquals(TransactionType.DEPOSIT, transaction.type)&#10;        assertEquals(50.0, transaction.amount)&#10;        assertEquals(&quot;Depósito Teste&quot;, transaction.description)&#10;        assertNotNull(transaction.createdAt)&#10;        assertEquals(TransactionStatus.COMPLETED, transaction.status)&#10;    }&#10;&#10;    @Test&#10;    fun `nao deve permitir deposito com valor negativo`() {&#10;        // given, when, then&#10;        val exception = assertThrows(IllegalArgumentException::class.java) {&#10;            transactionService.deposit(1, -10.0, &quot;Depósito Negativo&quot;)&#10;        }&#10;        assertEquals(&quot;O valor do depósito deve ser maior que zero.&quot;, exception.message)&#10;    }&#10;&#10;    @Test&#10;    fun `deve realizar saque com sucesso`() {&#10;        // given&#10;        val account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(account)&#10;        val slotAccount = slot&lt;Account&gt;()&#10;        every { accountRepository.save(capture(slotAccount)) } answers { slotAccount.captured }&#10;        val slotTransaction = slot&lt;Transaction&gt;()&#10;        every { transactionRepository.save(capture(slotTransaction)) } answers { slotTransaction.captured }&#10;&#10;        // when&#10;        val transaction = transactionService.withdraw(1, 40.0, &quot;Saque Teste&quot;)&#10;&#10;        // then&#10;        assertEquals(60.0, slotAccount.captured.balance)&#10;        assertEquals(TransactionType.WITHDRAWAL, transaction.type)&#10;        assertEquals(40.0, transaction.amount)&#10;        assertEquals(&quot;Saque Teste&quot;, transaction.description)&#10;        assertNotNull(transaction.createdAt)&#10;        assertEquals(TransactionStatus.COMPLETED, transaction.status)&#10;    }&#10;&#10;    @Test&#10;    fun `nao deve permitir saque com saldo insuficiente`() {&#10;        // given&#10;        val account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 20.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(account)&#10;        // when, then&#10;        val exception = assertThrows(IllegalArgumentException::class.java) {&#10;            transactionService.withdraw(1, 50.0, &quot;Saque Teste&quot;)&#10;        }&#10;        assertEquals(&quot;Saldo insuficiente para realizar o saque.&quot;, exception.message)&#10;    }&#10;&#10;    @Test&#10;    fun `deve realizar transferencia com sucesso`() {&#10;        // given&#10;        val address = Address(street = &quot;Rua Teste&quot;, number = &quot;123&quot;, city = &quot;Cidade&quot;, state = &quot;ST&quot;, zipCode = &quot;00000-000&quot;)&#10;        val phone = Phone(countryCode = &quot;+55&quot;, areaCode = &quot;11&quot;, numberCode = &quot;999999999&quot;)&#10;        val clientFrom = Client(&#10;            id = 1,&#10;            name = &quot;Cliente Origem&quot;,&#10;            email = &quot;origem@email.com&quot;,&#10;            cpf = &quot;12345678900&quot;,&#10;            birthDate = LocalDate.now().minusYears(30),&#10;            address = address,&#10;            phone = phone,&#10;            password = &quot;123456&quot;&#10;        )&#10;        val clientTo = Client(&#10;            id = 2,&#10;            name = &quot;Cliente Destino&quot;,&#10;            email = &quot;destino@email.com&quot;,&#10;            cpf = &quot;09876543211&quot;,&#10;            birthDate = LocalDate.now().minusYears(25),&#10;            address = address,&#10;            phone = phone,&#10;            password = &quot;654321&quot;&#10;        )&#10;        val fromAccount = Account(id = 1, accountNumber = &quot;123&quot;, balance = 200.0, client = clientFrom)&#10;        val toAccount = Account(id = 2, accountNumber = &quot;456&quot;, balance = 50.0, client = clientTo)&#10;        every { accountRepository.findById(1) } returns Optional.of(fromAccount)&#10;        every { accountRepository.findByAccountNumber(&quot;456&quot;) } returns toAccount&#10;        val slotFrom = slot&lt;Account&gt;()&#10;        val slotTo = slot&lt;Account&gt;()&#10;        every { accountRepository.save(capture(slotFrom)) } answers { slotFrom.captured }&#10;        every { accountRepository.save(capture(slotTo)) } answers { slotTo.captured }&#10;        val slotOut = slot&lt;Transaction&gt;()&#10;        val slotIn = slot&lt;Transaction&gt;()&#10;        every { transactionRepository.save(capture(slotOut)) } answers { slotOut.captured }&#10;        every { transactionRepository.save(capture(slotIn)) } answers { slotIn.captured }&#10;&#10;        // when&#10;        val (outTransaction, inTransaction) = transactionService.transfer(1, &quot;456&quot;, 100.0, &quot;Transferência Teste&quot;)&#10;&#10;        // then&#10;        assertEquals(100.0, slotFrom.captured.balance)&#10;        assertEquals(150.0, slotTo.captured.balance)&#10;        assertEquals(TransactionType.TRANSFER_OUT, outTransaction.type)&#10;        assertEquals(TransactionType.TRANSFER_IN, inTransaction.type)&#10;        assertEquals(100.0, outTransaction.amount)&#10;        assertEquals(100.0, inTransaction.amount)&#10;        assertEquals(&quot;Transferência Teste&quot;, outTransaction.description)&#10;        assertEquals(&quot;Transferência Teste&quot;, inTransaction.description)&#10;    }&#10;&#10;    @Test&#10;    fun `nao deve permitir transferencia para mesma conta`() {&#10;        // given&#10;        val fromAccount = Account(id = 1, accountNumber = &quot;123&quot;, balance = 200.0)&#10;        every { accountRepository.findById(1) } returns Optional.of(fromAccount)&#10;        every { accountRepository.findByAccountNumber(&quot;123&quot;) } returns fromAccount&#10;        // when, then&#10;        val exception = assertThrows(IllegalArgumentException::class.java) {&#10;            transactionService.transfer(1, &quot;123&quot;, 50.0, &quot;Transferência Inválida&quot;)&#10;        }&#10;        assertEquals(&quot;Não é possível transferir para a mesma conta.&quot;, exception.message)&#10;    }&#10;&#10;    @Test&#10;    fun `deve buscar transacoes por conta`() {&#10;        // given&#10;        val accountId = 1L&#10;        val transactions = listOf(&#10;            Transaction(id = 1, account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0), type = TransactionType.DEPOSIT, amount = 50.0, description = &quot;Depósito&quot;, createdAt = LocalDateTime.now()),&#10;            Transaction(id = 2, account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 150.0), type = TransactionType.WITHDRAWAL, amount = 20.0, description = &quot;Saque&quot;, createdAt = LocalDateTime.now())&#10;        )&#10;        every { transactionRepository.findByAccountIdOrderByCreatedAtDesc(accountId) } returns transactions&#10;        // when&#10;        val result = transactionService.getTransactionsByAccount(accountId)&#10;        // then&#10;        assertEquals(2, result.size)&#10;        assertEquals(TransactionType.DEPOSIT, result[0].type)&#10;        assertEquals(TransactionType.WITHDRAWAL, result[1].type)&#10;    }&#10;&#10;    @Test&#10;    fun `deve buscar ultimas 10 transacoes por conta`() {&#10;        // given&#10;        val accountId = 1L&#10;        val transactions = List(10) {&#10;            Transaction(id = it.toLong(), account = Account(id = 1, accountNumber = &quot;123&quot;, balance = 100.0), type = TransactionType.DEPOSIT, amount = 10.0, description = &quot;Depósito $it&quot;, createdAt = LocalDateTime.now())&#10;        }&#10;        every { transactionRepository.findTop10ByAccountIdOrderByCreatedAtDesc(accountId) } returns transactions&#10;        // when&#10;        val result = transactionService.getRecentTransactionsByAccount(accountId)&#10;        // then&#10;        assertEquals(10, result.size)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>